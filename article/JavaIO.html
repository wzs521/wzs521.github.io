<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JavaI/O | WZS-DJR's blog</title><meta name="description" content="JavaI&#x2F;OJava语言定义了许多类专门负责各种方式的输入和输出，这些类被放在java.io中。其中，所有输入流类都是抽象类InputStream（字节输入流）或抽象类Reader（字符输入流）的子类；而所有输出流都是抽象类OutStream（字节输出流）或抽象类Writer（字符输出流）的子类     一、概览Java 的 I&#x2F;O 大概可以分成以下几类： 磁盘操作：File字节操作：Input"><meta name="keywords" content="Java,I/O"><meta name="author" content="WZS-DJR"><meta name="copyright" content="WZS-DJR"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://djrhhh.tk/article/JavaIO.html"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="JavaI/O"><meta property="og:url" content="https://djrhhh.tk/article/JavaIO.html"><meta property="og:site_name" content="WZS-DJR's blog"><meta property="og:description" content="JavaI&#x2F;OJava语言定义了许多类专门负责各种方式的输入和输出，这些类被放在java.io中。其中，所有输入流类都是抽象类InputStream（字节输入流）或抽象类Reader（字符输入流）的子类；而所有输出流都是抽象类OutStream（字节输出流）或抽象类Writer（字符输出流）的子类     一、概览Java 的 I&#x2F;O 大概可以分成以下几类： 磁盘操作：File字节操作：Input"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2019-11-14T03:39:00.000Z"><meta property="article:modified_time" content="2020-07-26T13:06:36.892Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-07-26 21:06:36'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">34</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">41</div></a></div></div></div><hr/></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaI-O"><span class="toc-number">1.</span> <span class="toc-text">JavaI&#x2F;O</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#一、概览"><span class="toc-number">2.</span> <span class="toc-text">一、概览</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、磁盘操作"><span class="toc-number">3.</span> <span class="toc-text">二、磁盘操作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、字节操作"><span class="toc-number">4.</span> <span class="toc-text">三、字节操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#实现文件复制"><span class="toc-number">4.1.</span> <span class="toc-text">实现文件复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#装饰者模式"><span class="toc-number">4.2.</span> <span class="toc-text">装饰者模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四、字符操作"><span class="toc-number">5.</span> <span class="toc-text">四、字符操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#编码与解码"><span class="toc-number">5.1.</span> <span class="toc-text">编码与解码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-的编码方式"><span class="toc-number">5.2.</span> <span class="toc-text">String 的编码方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reader-与-Writer"><span class="toc-number">5.3.</span> <span class="toc-text">Reader 与 Writer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现逐行输出文本文件的内容"><span class="toc-number">5.4.</span> <span class="toc-text">实现逐行输出文本文件的内容</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#五、对象操作"><span class="toc-number">6.</span> <span class="toc-text">五、对象操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#序列化"><span class="toc-number">6.1.</span> <span class="toc-text">序列化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Serializable"><span class="toc-number">6.2.</span> <span class="toc-text">Serializable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#transient"><span class="toc-number">6.3.</span> <span class="toc-text">transient</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、网络操作"><span class="toc-number">6.4.</span> <span class="toc-text">六、网络操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InetAddress"><span class="toc-number">6.5.</span> <span class="toc-text">InetAddress</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#URL"><span class="toc-number">6.6.</span> <span class="toc-text">URL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sockets"><span class="toc-number">6.7.</span> <span class="toc-text">Sockets</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Datagram"><span class="toc-number">6.8.</span> <span class="toc-text">Datagram</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#七、NIO"><span class="toc-number">7.</span> <span class="toc-text">七、NIO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#流与块"><span class="toc-number">7.1.</span> <span class="toc-text">流与块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#通道与缓冲区"><span class="toc-number">7.2.</span> <span class="toc-text">通道与缓冲区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-通道"><span class="toc-number">7.2.1.</span> <span class="toc-text">1. 通道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-缓冲区"><span class="toc-number">7.2.2.</span> <span class="toc-text">2. 缓冲区</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#缓冲区状态变量"><span class="toc-number">7.3.</span> <span class="toc-text">缓冲区状态变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#文件-NIO-实例"><span class="toc-number">7.4.</span> <span class="toc-text">文件 NIO 实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#选择器"><span class="toc-number">7.5.</span> <span class="toc-text">选择器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-创建选择器"><span class="toc-number">7.5.1.</span> <span class="toc-text">1. 创建选择器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-将通道注册到选择器上"><span class="toc-number">7.5.2.</span> <span class="toc-text">2. 将通道注册到选择器上</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-监听事件"><span class="toc-number">7.5.3.</span> <span class="toc-text">3. 监听事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-获取到达的事件"><span class="toc-number">7.5.4.</span> <span class="toc-text">4. 获取到达的事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-事件循环"><span class="toc-number">7.5.5.</span> <span class="toc-text">5. 事件循环</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#套接字-NIO-实例"><span class="toc-number">7.6.</span> <span class="toc-text">套接字 NIO 实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存映射文件"><span class="toc-number">7.7.</span> <span class="toc-text">内存映射文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对比"><span class="toc-number">7.8.</span> <span class="toc-text">对比</span></a></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">WZS-DJR's blog</a></span><span class="pull-right menus"><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">JavaI/O</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-11-14T03:39:00.000Z" title="发表于 2019-11-14 11:39:00">2019-11-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-07-26T13:06:36.892Z" title="更新于 2020-07-26 21:06:36">2020-07-26</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="JavaI-O"><a href="#JavaI-O" class="headerlink" title="JavaI/O"></a>JavaI/O</h1><p>Java语言定义了许多类专门负责各种方式的输入和输出，这些类被放在java.io中。其中，所有输入流类都是抽象类InputStream（字节输入流）或抽象类Reader（字符输入流）的子类；而所有输出流都是抽象类OutStream（字节输出流）或抽象类Writer（字符输出流）的子类</p>
<a id="more"></a>



<h1 id="一、概览"><a href="#一、概览" class="headerlink" title="一、概览"></a>一、概览</h1><p>Java 的 I/O 大概可以分成以下几类：</p>
<p>磁盘操作：File<br>字节操作：InputStream 和 OutputStream<br>字符操作：Reader 和 Writer<br>对象操作：Serializable<br>网络操作：Socket<br>新的输入/输出：NIO</p>
<h1 id="二、磁盘操作"><a href="#二、磁盘操作" class="headerlink" title="二、磁盘操作"></a>二、磁盘操作</h1><p>File 类可以用于表示文件和目录的信息，但是它不表示文件的内容。</p>
<p>递归地列出一个目录下所有文件：</p>
<p>public static void listAllFiles(File dir) {<br>    if (dir == null || !dir.exists()) {<br>        return;<br>    }<br>    if (dir.isFile()) {<br>        System.out.println(dir.getName());<br>        return;<br>    }<br>    for (File file : dir.listFiles()) {<br>        listAllFiles(file);<br>    }<br>}<br>从 Java7 开始，可以使用 Paths 和 Files 代替 File。</p>
<h1 id="三、字节操作"><a href="#三、字节操作" class="headerlink" title="三、字节操作"></a>三、字节操作</h1><h2 id="实现文件复制"><a href="#实现文件复制" class="headerlink" title="实现文件复制"></a>实现文件复制</h2><p>public static void copyFile(String src, String dist) throws IOException {<br>    FileInputStream in = new FileInputStream(src);<br>    FileOutputStream out = new FileOutputStream(dist);</p>
<pre><code>byte[] buffer = new byte[20 * 1024];
int cnt;

// read() 最多读取 buffer.length 个字节
// 返回的是实际读取的个数
// 返回 -1 的时候表示读到 eof，即文件尾
while ((cnt = in.read(buffer, 0, buffer.length)) != -1) {
    out.write(buffer, 0, cnt);
}

in.close();
out.close();</code></pre><p>}</p>
<h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p>Java I/O 使用了装饰者模式来实现。以 InputStream 为例，</p>
<p>InputStream 是抽象组件；<br>FileInputStream 是 InputStream 的子类，属于具体组件，提供了字节流的输入操作；<br>FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。<br><img src= "/img/loading.gif" data-lazy-src="https://camo.githubusercontent.com/d650ccc4ec1a0c99171582d9ccc9a5003155496f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39373039363934622d646230352d346363652d386432662d3163386230396634643932312e706e67"/></p>
<p>实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可。</p>
<p>FileInputStream fileInputStream = new FileInputStream(filePath);<br>BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream);<br>DataInputStream 装饰者提供了对更多数据类型进行输入的操作，比如 int、double 等基本类型。</p>
<h1 id="四、字符操作"><a href="#四、字符操作" class="headerlink" title="四、字符操作"></a>四、字符操作</h1><h2 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h2><p>编码就是把字符转换为字节，而解码是把字节重新组合成字符。</p>
<p>如果编码和解码过程使用不同的编码方式那么就出现了乱码。</p>
<p>GBK 编码中，中文字符占 2 个字节，英文字符占 1 个字节；<br>UTF-8 编码中，中文字符占 3 个字节，英文字符占 1 个字节；<br>UTF-16be 编码中，中文字符和英文字符都占 2 个字节。<br>UTF-16be 中的 be 指的是 Big Endian，也就是大端。相应地也有 UTF-16le，le 指的是 Little Endian，也就是小端。</p>
<p>Java 的内存编码使用双字节编码 UTF-16be，这不是指 Java 只支持这一种编码方式，而是说 char 这种类型使用 UTF-16be 进行编码。char 类型占 16 位，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储。</p>
<h2 id="String-的编码方式"><a href="#String-的编码方式" class="headerlink" title="String 的编码方式"></a>String 的编码方式</h2><p>String 可以看成一个字符序列，可以指定一个编码方式将它编码为字节序列，也可以指定一个编码方式将一个字节序列解码为 String。</p>
<p>String str1 = “中文”;<br>byte[] bytes = str1.getBytes(“UTF-8”);<br>String str2 = new String(bytes, “UTF-8”);<br>System.out.println(str2);<br>在调用无参数 getBytes() 方法时，默认的编码方式不是 UTF-16be。双字节编码的好处是可以使用一个 char 存储中文和英文，而将 String 转为 bytes[] 字节数组就不再需要这个好处，因此也就不再需要双字节编码。getBytes() 的默认编码方式与平台有关，一般为 UTF-8。</p>
<p>byte[] bytes = str1.getBytes();</p>
<h2 id="Reader-与-Writer"><a href="#Reader-与-Writer" class="headerlink" title="Reader 与 Writer"></a>Reader 与 Writer</h2><p>不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符。但是在程序中操作的通常是字符形式的数据，因此需要提供对字符进行操作的方法。</p>
<p>InputStreamReader 实现从字节流解码成字符流；<br>OutputStreamWriter 实现字符流编码成为字节流。</p>
<h2 id="实现逐行输出文本文件的内容"><a href="#实现逐行输出文本文件的内容" class="headerlink" title="实现逐行输出文本文件的内容"></a>实现逐行输出文本文件的内容</h2><p>public static void readFileContent(String filePath) throws IOException {</p>
<pre><code>FileReader fileReader = new FileReader(filePath);
BufferedReader bufferedReader = new BufferedReader(fileReader);

String line;
while ((line = bufferedReader.readLine()) != null) {
    System.out.println(line);
}

// 装饰者模式使得 BufferedReader 组合了一个 Reader 对象
// 在调用 BufferedReader 的 close() 方法时会去调用 Reader 的 close() 方法
// 因此只要一个 close() 调用即可
bufferedReader.close();</code></pre><p>}</p>
<h1 id="五、对象操作"><a href="#五、对象操作" class="headerlink" title="五、对象操作"></a>五、对象操作</h1><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>序列化就是将一个对象转换成字节序列，方便存储和传输。</p>
<p>序列化：ObjectOutputStream.writeObject()<br>反序列化：ObjectInputStream.readObject()<br>不会对静态变量进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态。</p>
<h2 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h2><p>序列化的类需要实现 Serializable 接口，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常。</p>
<p>public static void main(String[] args) throws IOException, ClassNotFoundException {</p>
<pre><code>A a1 = new A(123, &quot;abc&quot;);
String objectFile = &quot;file/a1&quot;;

ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(objectFile));
objectOutputStream.writeObject(a1);
objectOutputStream.close();

ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(objectFile));
A a2 = (A) objectInputStream.readObject();
objectInputStream.close();
System.out.println(a2);</code></pre><p>}</p>
<p>private static class A implements Serializable {</p>
<pre><code>private int x;
private String y;

A(int x, String y) {
    this.x = x;
    this.y = y;
}

@Override
public String toString() {
    return &quot;x = &quot; + x + &quot;  &quot; + &quot;y = &quot; + y;
}</code></pre><p>}</p>
<h2 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h2><p>transient 关键字可以使一些属性不会被序列化。</p>
<p>ArrayList 中存储数据的数组 elementData 是用 transient 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据。</p>
<p>private transient Object[] elementData;</p>
<h2 id="六、网络操作"><a href="#六、网络操作" class="headerlink" title="六、网络操作"></a>六、网络操作</h2><p>Java 中的网络支持：</p>
<p>InetAddress：用于表示网络上的硬件资源，即 IP 地址；<br>URL：统一资源定位符；<br>Sockets：使用 TCP 协议实现网络通信；<br>Datagram：使用 UDP 协议实现网络通信。</p>
<h2 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h2><p>没有公有的构造函数，只能通过静态方法来创建实例。</p>
<p>InetAddress.getByName(String host);<br>InetAddress.getByAddress(byte[] address);</p>
<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>可以直接从 URL 中读取字节流数据。</p>
<p>public static void main(String[] args) throws IOException {</p>
<pre><code>URL url = new URL(&quot;http://www.baidu.com&quot;);

/* 字节流 */
InputStream is = url.openStream();

/* 字符流 */
InputStreamReader isr = new InputStreamReader(is, &quot;utf-8&quot;);

/* 提供缓存功能 */
BufferedReader br = new BufferedReader(isr);

String line;
while ((line = br.readLine()) != null) {
    System.out.println(line);
}

br.close();</code></pre><p>}</p>
<h2 id="Sockets"><a href="#Sockets" class="headerlink" title="Sockets"></a>Sockets</h2><p>ServerSocket：服务器端类<br>Socket：客户端类<br>服务器和客户端通过 InputStream 和 OutputStream 进行输入输出。</p>
<h2 id="Datagram"><a href="#Datagram" class="headerlink" title="Datagram"></a>Datagram</h2><p>DatagramSocket：通信类<br>DatagramPacket：数据包类</p>
<h1 id="七、NIO"><a href="#七、NIO" class="headerlink" title="七、NIO"></a>七、NIO</h1><p>新的输入/输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I/O 的不足，提供了高速的、面向块的 I/O。</p>
<h2 id="流与块"><a href="#流与块" class="headerlink" title="流与块"></a>流与块</h2><p>I/O 与 NIO 最重要的区别是数据打包和传输的方式，I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。</p>
<p>面向流的 I/O 一次处理一个字节数据：一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 I/O 通常相当慢。</p>
<p>面向块的 I/O 一次处理一个数据块，按块处理数据比按流处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。</p>
<p>I/O 包和 NIO 已经很好地集成了，java.io.* 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。例如，java.io.* 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。</p>
<h2 id="通道与缓冲区"><a href="#通道与缓冲区" class="headerlink" title="通道与缓冲区"></a>通道与缓冲区</h2><h3 id="1-通道"><a href="#1-通道" class="headerlink" title="1. 通道"></a>1. 通道</h3><p>通道 Channel 是对原 I/O 包中的流的模拟，可以通过它读取和写入数据。</p>
<p>通道与流的不同之处在于，流只能在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)，而通道是双向的，可以用于读、写或者同时用于读写。</p>
<p>通道包括以下类型：</p>
<p>FileChannel：从文件中读写数据；<br>DatagramChannel：通过 UDP 读写网络中数据；<br>SocketChannel：通过 TCP 读写网络中数据；<br>ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。</p>
<h3 id="2-缓冲区"><a href="#2-缓冲区" class="headerlink" title="2. 缓冲区"></a>2. 缓冲区</h3><p>发送给一个通道的所有数据都必须首先放到缓冲区中，同样地，从通道中读取的任何数据都要先读到缓冲区中。也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。</p>
<p>缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。</p>
<p>缓冲区包括以下类型：</p>
<p>ByteBuffer<br>CharBuffer<br>ShortBuffer<br>IntBuffer<br>LongBuffer<br>FloatBuffer<br>DoubleBuffer</p>
<h2 id="缓冲区状态变量"><a href="#缓冲区状态变量" class="headerlink" title="缓冲区状态变量"></a>缓冲区状态变量</h2><p>capacity：最大容量；<br>position：当前已经读写的字节数；<br>limit：还可以读写的字节数。<br>状态变量的改变过程举例：</p>
<p>① 新建一个大小为 8 个字节的缓冲区，此时 position 为 0，而 limit = capacity = 8。capacity 变量不会改变，下面的讨论会忽略它。<br><img src= "/img/loading.gif" data-lazy-src="https://camo.githubusercontent.com/2a7124242c8d67203a0644255fa0c266ab047afa/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31626561333938662d313761372d346636372d613930622d3965326432343365616139612e706e67"/></p>
<p>② 从输入通道中读取 5 个字节数据写入缓冲区中，此时 position 为 5，limit 保持不变。<br><img src= "/img/loading.gif" data-lazy-src="https://camo.githubusercontent.com/cbbc8451d44890665c19f2a38df033cb9e871ab0/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38303830346635322d383831352d343039362d623530362d3438656566336565643563362e706e67"/></p>
<p>③ 在将缓冲区的数据写到输出通道之前，需要先调用 flip() 方法，这个方法将 limit 设置为当前 position，并将 position 设置为 0。</p>
<img src= "/img/loading.gif" data-lazy-src="https://camo.githubusercontent.com/8bbcea5699a8eea9c58fc91686ba864aa3c23ff9/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39353265303662642d356136352d346361622d383265342d6464313533363436326633382e706e67"/>

<p>④ 从缓冲区中取 4 个字节到输出缓冲中，此时 position 设为 4。</p>
<img src= "/img/loading.gif" data-lazy-src="https://camo.githubusercontent.com/f075744aafa9559fffb84311e34036d6d66b9b7f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62356264636265322d623935382d346165662d393135312d3661643936336362323862342e706e67"/>

<p>⑤ 最后需要调用 clear() 方法来清空缓冲区，此时 position 和 limit 都被设置为最初位置。</p>
<img src= "/img/loading.gif" data-lazy-src="https://camo.githubusercontent.com/249f208058a7acab94a75516a404eb2dde74a816/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36376266353438372d633435642d343962362d623963302d6130353864386336383930322e706e67"/>

<h2 id="文件-NIO-实例"><a href="#文件-NIO-实例" class="headerlink" title="文件 NIO 实例"></a>文件 NIO 实例</h2><p>以下展示了使用 NIO 快速复制文件的实例：</p>
<p>public static void fastCopy(String src, String dist) throws IOException {</p>
<pre><code>/* 获得源文件的输入字节流 */
FileInputStream fin = new FileInputStream(src);

/* 获取输入字节流的文件通道 */
FileChannel fcin = fin.getChannel();

/* 获取目标文件的输出字节流 */
FileOutputStream fout = new FileOutputStream(dist);

/* 获取输出字节流的文件通道 */
FileChannel fcout = fout.getChannel();

/* 为缓冲区分配 1024 个字节 */
ByteBuffer buffer = ByteBuffer.allocateDirect(1024);

while (true) {

    /* 从输入通道中读取数据到缓冲区中 */
    int r = fcin.read(buffer);

    /* read() 返回 -1 表示 EOF */
    if (r == -1) {
        break;
    }

    /* 切换读写 */
    buffer.flip();

    /* 把缓冲区的内容写入输出文件中 */
    fcout.write(buffer);

    /* 清空缓冲区 */
    buffer.clear();
}</code></pre><p>}</p>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>NIO 常常被叫做非阻塞 IO，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用。</p>
<p>NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。</p>
<p>通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。</p>
<p>因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件，对于 IO 密集型的应用具有很好地性能。</p>
<p>应该注意的是，只有套接字 Channel 才能配置为非阻塞，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义。</p>
<h3 id="1-创建选择器"><a href="#1-创建选择器" class="headerlink" title="1. 创建选择器"></a>1. 创建选择器</h3><p>Selector selector = Selector.open();</p>
<h3 id="2-将通道注册到选择器上"><a href="#2-将通道注册到选择器上" class="headerlink" title="2. 将通道注册到选择器上"></a>2. 将通道注册到选择器上</h3><p>ServerSocketChannel ssChannel = ServerSocketChannel.open();<br>ssChannel.configureBlocking(false);<br>ssChannel.register(selector, SelectionKey.OP_ACCEPT);<br>通道必须配置为非阻塞模式，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰。</p>
<p>在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类：</p>
<p>SelectionKey.OP_CONNECT<br>SelectionKey.OP_ACCEPT<br>SelectionKey.OP_READ<br>SelectionKey.OP_WRITE<br>它们在 SelectionKey 的定义如下：</p>
<p>public static final int OP_READ = 1 &lt;&lt; 0;<br>public static final int OP_WRITE = 1 &lt;&lt; 2;<br>public static final int OP_CONNECT = 1 &lt;&lt; 3;<br>public static final int OP_ACCEPT = 1 &lt;&lt; 4;<br>可以看出每个事件可以被当成一个位域，从而组成事件集整数。例如：</p>
<p>int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</p>
<h3 id="3-监听事件"><a href="#3-监听事件" class="headerlink" title="3. 监听事件"></a>3. 监听事件</h3><p>int num = selector.select();<br>使用 select() 来监听到达的事件，它会一直阻塞直到有至少一个事件到达。</p>
<h3 id="4-获取到达的事件"><a href="#4-获取到达的事件" class="headerlink" title="4. 获取到达的事件"></a>4. 获取到达的事件</h3><p>Set<SelectionKey> keys = selector.selectedKeys();<br>Iterator<SelectionKey> keyIterator = keys.iterator();<br>while (keyIterator.hasNext()) {<br>    SelectionKey key = keyIterator.next();<br>    if (key.isAcceptable()) {<br>        // …<br>    } else if (key.isReadable()) {<br>        // …<br>    }<br>    keyIterator.remove();<br>}</p>
<h3 id="5-事件循环"><a href="#5-事件循环" class="headerlink" title="5. 事件循环"></a>5. 事件循环</h3><p>因为一次 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。</p>
<p>while (true) {<br>    int num = selector.select();<br>    Set<SelectionKey> keys = selector.selectedKeys();<br>    Iterator<SelectionKey> keyIterator = keys.iterator();<br>    while (keyIterator.hasNext()) {<br>        SelectionKey key = keyIterator.next();<br>        if (key.isAcceptable()) {<br>            // …<br>        } else if (key.isReadable()) {<br>            // …<br>        }<br>        keyIterator.remove();<br>    }<br>}</p>
<h2 id="套接字-NIO-实例"><a href="#套接字-NIO-实例" class="headerlink" title="套接字 NIO 实例"></a>套接字 NIO 实例</h2><p>public class NIOServer {</p>
<pre><code>public static void main(String[] args) throws IOException {

    Selector selector = Selector.open();

    ServerSocketChannel ssChannel = ServerSocketChannel.open();
    ssChannel.configureBlocking(false);
    ssChannel.register(selector, SelectionKey.OP_ACCEPT);

    ServerSocket serverSocket = ssChannel.socket();
    InetSocketAddress address = new InetSocketAddress(&quot;127.0.0.1&quot;, 8888);
    serverSocket.bind(address);

    while (true) {

        selector.select();
        Set&lt;SelectionKey&gt; keys = selector.selectedKeys();
        Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();

        while (keyIterator.hasNext()) {

            SelectionKey key = keyIterator.next();

            if (key.isAcceptable()) {

                ServerSocketChannel ssChannel1 = (ServerSocketChannel) key.channel();

                // 服务器会为每个新连接创建一个 SocketChannel
                SocketChannel sChannel = ssChannel1.accept();
                sChannel.configureBlocking(false);

                // 这个新连接主要用于从客户端读取数据
                sChannel.register(selector, SelectionKey.OP_READ);

            } else if (key.isReadable()) {

                SocketChannel sChannel = (SocketChannel) key.channel();
                System.out.println(readDataFromSocketChannel(sChannel));
                sChannel.close();
            }

            keyIterator.remove();
        }
    }
}

private static String readDataFromSocketChannel(SocketChannel sChannel) throws IOException {

    ByteBuffer buffer = ByteBuffer.allocate(1024);
    StringBuilder data = new StringBuilder();

    while (true) {

        buffer.clear();
        int n = sChannel.read(buffer);
        if (n == -1) {
            break;
        }
        buffer.flip();
        int limit = buffer.limit();
        char[] dst = new char[limit];
        for (int i = 0; i &lt; limit; i++) {
            dst[i] = (char) buffer.get(i);
        }
        data.append(dst);
        buffer.clear();
    }
    return data.toString();
}</code></pre><p>}<br>public class NIOClient {</p>
<pre><code>public static void main(String[] args) throws IOException {
    Socket socket = new Socket(&quot;127.0.0.1&quot;, 8888);
    OutputStream out = socket.getOutputStream();
    String s = &quot;hello world&quot;;
    out.write(s.getBytes());
    out.close();
}</code></pre><p>}</p>
<h2 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h2><p>内存映射文件 I/O 是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的 I/O 快得多。</p>
<p>向内存映射文件写入可能是危险的，只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。</p>
<p>下面代码行将文件的前 1024 个字节映射到内存中，map() 方法返回一个 MappedByteBuffer，它是 ByteBuffer 的子类。因此，可以像使用其他任何 ByteBuffer 一样使用新映射的缓冲区，操作系统会在需要时负责执行映射。</p>
<p>MappedByteBuffer mbb = fc.map(FileChannel.MapMode.READ_WRITE, 0, 1024);</p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>NIO 与普通 I/O 的区别主要有以下两点：</p>
<p>NIO 是非阻塞的；<br>NIO 面向块，I/O 面向流。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">WZS-DJR</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://djrhhh.tk/article/JavaIO.html">https://djrhhh.tk/article/JavaIO.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://djrhhh.tk" target="_blank">WZS-DJR's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/I-O/">I/O</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/article/8ffb0d96.html"><img class="prev-cover" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">单向环形链表</div></div></a></div><div class="next-post pull-right"><a href="/article/docker.html"><img class="next-cover" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Docker</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/article/918971b1.html" title="Java并发"><img class="relatedPosts_cover" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2018-01-21</div><div class="relatedPosts_title">Java并发</div></div></a></div><div class="relatedPosts_item"><a href="/article/515d78b5.html" title="Java虚拟机"><img class="relatedPosts_cover" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2019-02-14</div><div class="relatedPosts_title">Java虚拟机</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2017 - 2020 By WZS-DJR</div><div class="framework-info"><span>框架 </span><a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>